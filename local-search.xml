<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue基础内容</title>
    <link href="/2021/03/08/vue%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/08/vue%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs vim">day01<br>vue介绍<br>认识vue<br>特点： 易用、灵活、高效<br>版本：<span class="hljs-number">2.6</span><br>作者：尤雨溪<br>兼容： IE8及以下不兼容<br>使用<br><span class="hljs-number">1</span>、引入vue.js<br>开发版本(development)<br>警告、提示、没有压缩<br>生产版本(production)<br>部署上线时候用的，删除了警告、提示、压缩了代码<br><span class="hljs-number">2</span>、创建挂载节点标签<br>不能是body或者html<br><span class="hljs-number">3</span>、实例化vue对象<br><span class="hljs-keyword">el</span><br>挂载节点的选择器<br>data<br>模板中用到的所有数据<br>&#123;&#123; data里面的变量 &#125;&#125;<br>&#123;&#123; 表达式 &#125;&#125;<br>MVVM<br>M    model（data里面的数据）<br>V  <span class="hljs-keyword">view</span>(视图，就是模板)<br>VM (虚拟模型)<br>vue指令<br>指令是什么： 是自定义属性  <br>&lt;标签 v-指令名=<span class="hljs-string">&quot;变量/表达式&quot;</span> /&gt;<br>常用指令<br>v-html<br>渲染内容，可以编译html字符串<br>v-text<br>渲染内容<br>v-cloak<br>防止闪烁<br>v-<span class="hljs-keyword">pre</span><br>跳过编译<br>v-once<br>一次性绑定<br>v-<span class="hljs-keyword">on</span><br>事件绑定<br>v-bind<br>属性绑定<br>v-model<br>双向绑定<br>v-<span class="hljs-keyword">if</span><br>v-<span class="hljs-keyword">if</span><br>v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span><br>v-<span class="hljs-keyword">else</span><br>v-<span class="hljs-keyword">for</span><br>vue事件<br>绑定<br>&lt;标签 v-<span class="hljs-keyword">on</span>:事件类型=<span class="hljs-string">&quot;事件函数&quot;</span> /&gt;<br>&lt;标签 v-<span class="hljs-keyword">on</span>:事件类型=<span class="hljs-string">&quot;事件函数()&quot;</span> /&gt;<br>&lt;标签 @事件类型=<span class="hljs-string">&quot;事件函数&quot;</span> /&gt;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>   <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span><span class="hljs-string">&quot;&quot;</span>,<br>  dat<span class="hljs-variable">a:</span>&#123;&#125;,<br>  method<span class="hljs-variable">s:</span>&#123;<br>    事件函数()&#123; ... &#125;<br>  &#125;<br>&#125;)<br>传参<br>&lt;标签 @事件类型=<span class="hljs-string">&quot;事件函数(实参)&quot;</span> /&gt;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>   <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span><span class="hljs-string">&quot;&quot;</span>,<br>  dat<span class="hljs-variable">a:</span>&#123;&#125;,<br>  method<span class="hljs-variable">s:</span>&#123;<br>    事件函数(形参)&#123; ... &#125;<br>  &#125;<br>&#125;)<br>事件对象<br>&lt;标签 @事件类型=<span class="hljs-string">&quot;事件函数&quot;</span> /&gt;<br>&lt;标签 @事件类型=<span class="hljs-string">&quot;事件函数($event)&quot;</span> /&gt;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>   <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span><span class="hljs-string">&quot;&quot;</span>,<br>  dat<span class="hljs-variable">a:</span>&#123;&#125;,<br>  method<span class="hljs-variable">s:</span>&#123;<br>    事件函数(形参)&#123;  // 形参就是事件对象<br>           ...<br>   &#125;<br>  &#125;<br>&#125;)<br>既传参又获取事件对象<br>&lt;标签 @事件类型=<span class="hljs-string">&quot;事件函数($event,实参)&quot;</span> /&gt;<br><span class="hljs-keyword">new</span> Vue(&#123;<br>   <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span><span class="hljs-string">&quot;&quot;</span>,<br>  dat<span class="hljs-variable">a:</span>&#123;&#125;,<br>  method<span class="hljs-variable">s:</span>&#123;<br>    事件函数(形参<span class="hljs-number">1</span>，形参<span class="hljs-number">2</span>)&#123;  // 形参<span class="hljs-number">1</span>就是事件对象<br>           ...<br>   &#125;<br>  &#125;<br>&#125;)<br>事件简写<br>&lt;标签 @事件类型=<span class="hljs-string">&quot;变量赋值操作&quot;</span> /&gt;<br>事件修饰符<br>修饰符<br>&lt;标签 @事件类型.修饰符=<span class="hljs-string">&quot;事件函数&quot;</span> /&gt;<br>修饰符内容<br>.<span class="hljs-keyword">stop</span><br>.prevent<br>.self<br>.capture<br>.once<br>....<br>按键修饰符<br>按键相关事件<br>keydown<br>keyup<br>keypress<br><span class="hljs-built_in">input</span><br>自定义按键修饰符<br>Vue.config.keyCodes.修饰符名 = 按键码<br>vue样式<br>class<br>对象<br>&lt;标签 :class=<span class="hljs-string">&quot;&#123; class名1:变量1，class名2:变量2 &#125;&quot;</span> /&gt;<br>数组<br>&lt;标签 :class=<span class="hljs-string">&quot;[变量1，变量2,&#x27;class名1&#x27;,&#x27;class名2&#x27;]&quot;</span> /&gt;<br>属性绑定<br>&lt;标签 :class=<span class="hljs-string">&quot;条件 ？ &#x27;class名1&#x27;:&#x27;class名2&#x27; &quot;</span> /&gt;<br>style<br>对象<br>&lt;标签 :style=<span class="hljs-string">&quot;&#123; css属性名名1:变量1，css属性名2:变量2 &#125;&quot;</span> /&gt;<br>数组<br>&lt;标签 :style=<span class="hljs-string">&quot;[变量1，变量2]&quot;</span> /&gt;<br>变量<span class="hljs-number">1</span>:&#123; css属性名:css属性值 &#125;<br>变量<span class="hljs-number">2</span>:&#123; css属性名:css属性值 &#125;<br>属性绑定<br>&lt;标签 style=<span class="hljs-string">&quot;font-size:20px;border-color:red&quot;</span> /&gt;<br>&lt;标签 :style=<span class="hljs-string">&quot;`font-size:$&#123;a&#125;;border-color:$&#123;b&#125;`&quot;</span> /&gt;<br><span class="hljs-variable">a:</span><span class="hljs-string">&#x27;20px&#x27;</span><br><span class="hljs-variable">b:</span><span class="hljs-string">&#x27;red&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>session 与 jwt 的认证方案</title>
    <link href="/2021/02/27/jwt%E4%B8%8Esession%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88/"/>
    <url>/2021/02/27/jwt%E4%B8%8Esession%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>这是一篇个人总结的，关于 session 与 jwt 的认证方案 的笔记。</p><h2 id="首先，这个要从-http-协议的无状态性说起"><a href="#首先，这个要从-http-协议的无状态性说起" class="headerlink" title="首先，这个要从 http 协议的无状态性说起"></a>首先，这个要从 http 协议的无状态性说起</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">这个要从 <span class="hljs-keyword">http</span> 协议的无状态性说起<br>HTTP 协议的特点<br>HTTP 本身是一个无状态的协议, 它不会记录每次发送请求的用户信息, 这会导致服务器无法识别哪个用户发送了请求<br><br>如何解决上述的问题<br>可以借助 cookie 和 session 两种技术来存储用户的状态<br></code></pre></td></tr></table></figure><h2 id="什么是-cookie-呢？"><a href="#什么是-cookie-呢？" class="headerlink" title="什么是 cookie 呢？"></a>什么是 cookie 呢？</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Cookie 是存储在用户浏览器的一段不超过 <span class="hljs-number">4</span>KB 的字符串, 它是由一个名称<span class="hljs-comment">(Name)</span> 和 值<span class="hljs-comment">(Value)</span> 以及其他几个<br>用于控制 Cookie 有效期, 安全性, 使用范围的可选属性组成的<br><br>Cookie 的作用?<br>不用域名下的 Cookie 信息是独立的, 每当客户端发送请求时, 会自动把当前域名下所有未过期的 Cookie<br>添加到请求头, 一同发送到服务器<br><br>Cookie 的特性<br>      <span class="hljs-comment">(1)</span> 自动发送<br>      <span class="hljs-comment">(2)</span> 域名独立 <span class="hljs-comment">(不能跨域)</span><br>      <span class="hljs-comment">(3)</span> 过期时限<br>      <span class="hljs-comment">(4)</span> <span class="hljs-number">4</span> KB限制 <span class="hljs-comment">(了解即可)</span><br><br>Cookie 的工作机制<br>      客户端<span class="hljs-comment">(浏览器)</span>第一次发送请求到服务器, 服务器会以响应头的形式向浏览器写入 Cookie 保存,<br>      之后浏览器每次发送请求到服务器都会自动将 Cookie 以请求头的形式发送过去<br><br>    Cookie的更多操作: https:<span class="hljs-comment">//www.runoob.com/js/js-cookies.html</span><br></code></pre></td></tr></table></figure><h2 id="Cookie-技术的缺点"><a href="#Cookie-技术的缺点" class="headerlink" title="Cookie 技术的缺点"></a>Cookie 技术的缺点</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一、Cookie 技术的缺点<br>      Cookie 是存储在浏览器端的, 并且浏览器本身提供了读写 Cookie 的方法, 因此 Cookie 信息很容易被窃取和伪造,<br>    重要的隐私信息不建议存放在 Cookie 中<br>    <br>    二、如何解决上述的缺点<br>      使用 <span class="hljs-keyword">Session</span> 方案, 用户的状态信息在服务器生成和存储, 浏览器只负责保留一个 sessionID 秘钥, 每次发送请求<br>    时携带这个 sessionID 到服务器, 服务器根据这个唯一的 id 值查询对应的用户信息进行返回<br>    也就是数据不是直接发给客户端，而是只发送一个秘钥，数据是存在于服务端的，客户端登录时，只需要发送这个秘钥，返回这个唯一的秘钥对应的信息<br>    Cookie 里面存在的是 sessionID 秘钥，用户的真实信息 <span class="hljs-keyword">Session</span> 是一直存在于服务端<br></code></pre></td></tr></table></figure><h2 id="session-的不足之处"><a href="#session-的不足之处" class="headerlink" title="session 的不足之处"></a>session 的不足之处</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">一、Session 认证的局限性<br>   SessionID 需要配合 cookie  才能实现，由于 Cookie默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，<br>   需要做很多额外的配置，才能实现 Session 认证。<br><br><br> 二、如何解决上述的缺点<br>   当前端跨域请求后端接口时, 推荐使用 <span class="hljs-keyword">JWT </span>这种认证方式, 没有和 Cookie 的绑定关系<br><br><br> 三、什么是 <span class="hljs-keyword">JWT </span>(<span class="hljs-keyword">JSON </span>Web Token)?<br>   基于token的鉴权机制, 是前端目前最流行的跨域认证解决方案<br><br></code></pre></td></tr></table></figure><h2 id="session-的使用"><a href="#session-的使用" class="headerlink" title="session 的使用"></a>session 的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注意，以下代码并非完整，只是将重要的几个步骤写出来</span><br><span class="hljs-comment">// 先下载 express-session 包 与 express 包</span><br><br><span class="hljs-comment">// 1.导入 express 模块 与 引入 express-session 包</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br><span class="hljs-comment">// 2.配置 Session 中间件</span><br>app.use(session(&#123;<br>    <span class="hljs-comment">// 加密的秘钥</span><br>    secret: <span class="hljs-string">&#x27;12138&#x27;</span>,<br>    <span class="hljs-comment">// 下面两个是固定写法</span><br>    resave: <span class="hljs-literal">false</span>,<br>    saveUninitialized: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// cookie: &#123; secure: true &#125; //这个是 https 使用的，http 必须去掉</span><br>    <span class="hljs-comment">// 设置 cookie 的过期时间 一个小时后过期</span><br>    expires: <span class="hljs-string">&#x27;1h&#x27;</span><br>&#125;))<br><br><span class="hljs-comment">// 3.将登录成功后的用户信息，保存到 Session 中</span><br><span class="hljs-comment">// 注意: 只有成功配置了 express-session 这个中间件，才能通过 req 点出来 session 这个属性</span><br><span class="hljs-comment">// 如果用户名密码都正确 则请将登录成功后的用户信息，保存到 Session 中</span><br>req.session.user = req.body <span class="hljs-comment">//req.body 里面就是请求体的数据</span><br>req.session.isLogin = <span class="hljs-literal">true</span> <span class="hljs-comment">//用户的登录状态， true 表示登录</span><br><span class="hljs-built_in">console</span>.log(req.session.user); <span class="hljs-comment">//用户的账号密码</span><br><br> <span class="hljs-comment">// 4.从 Session 中获取用户的名称，响应给客户端</span><br>    <span class="hljs-comment">// 判断用户是否登录</span><br>    <span class="hljs-keyword">if</span> (req.session.isLogin != <span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">//不为 true 则代表没有登录</span><br>        <span class="hljs-keyword">return</span> res.send(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;没有登录！&#x27;</span> &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 如果已经登录,返回登录的信息，用户名为 req.session.user.username 里面获取到的用户名</span><br>    res.send(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;获取用户名成功&#x27;</span>, <span class="hljs-attr">username</span>: req.session.user.username &#125;)<br><br> <span class="hljs-comment">// 5.清空 Session 信息</span><br>    <span class="hljs-comment">// destroy() 方法，注意:调用 destroy 方法，只会清空当前用户的 session 信息, 不会清除其他用户的 session 信息</span><br>    <span class="hljs-comment">// 错误情况</span><br>    <span class="hljs-comment">// 300 代表从缓存里找的数据</span><br>    <span class="hljs-comment">// 404 客户端出错(地址，参数什么的错了) 极少数情况下是服务端出错(没有接口之类的)</span><br>    <span class="hljs-comment">// 500 服务端报错</span><br>    req.session.destroy() <span class="hljs-comment">//当前用户的 session 信息已销毁</span><br>    res.send(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;退出成功！&#x27;</span> &#125;)<br>        <span class="hljs-comment">// 一旦退出，就算你再去输入原来的 sessionid 秘钥，也无法直接登录到首页，所以就防止了伪造秘钥的行为</span><br><br></code></pre></td></tr></table></figure><h2 id="jwt-的认证机制"><a href="#jwt-的认证机制" class="headerlink" title="jwt 的认证机制"></a>jwt 的认证机制</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gauss">什么是 <span class="hljs-built_in">JWT</span> (JSON Web <span class="hljs-built_in">Token</span>)?<br>      基于<span class="hljs-built_in">token</span>的鉴权机制, 是前端目前最流行的跨域认证解决方案<br>注意: 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制<br>      当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制<br><br><br>  一、JWT 的认证机制<br>      用户信息通过加密签名后 <span class="hljs-built_in">token</span> 字符串的形式, 保存在客户端浏览器中. 服务器通过解密客户端传来的 <span class="hljs-built_in">token</span> 字符串<br>    来认证用户的身份<br>    <br>    二、JWT 的组成部分<br>      通常由三部分组成, 使用英文符号.进行分隔: Header.Payload.Signature<br>      <span class="hljs-built_in">Header</span>: 头部<br>      Payload: 有效荷载, 这里存放的是经过加密后的用户信息<br>      Signature: 签名<br>    <br>    三、JWT 使用方式<br>      <span class="hljs-number">1.</span>服务端签发 <span class="hljs-built_in">TOKEN</span> 到客户端后, 可以存储到 localStorage 中, <br>      <span class="hljs-number">2.</span>每次发送请求前都要带上这个 <span class="hljs-built_in">TOKEN</span>, 推荐放在 HTTP 请求头的 Authorization 字段中 (大事件项目中处理方式一致)s<br></code></pre></td></tr></table></figure><h2 id="jws-的使用"><a href="#jws-的使用" class="headerlink" title="jws 的使用"></a>jws 的使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-comment">// 在 Node.js项目中使用 JWT: </span><br>    <span class="hljs-comment">// 1. 先安装 JWT 包</span><br>    <span class="hljs-comment">// `npm  i jsonwebtoken express-jwt`</span><br><br>    <span class="hljs-comment">// 说明: jsonwebtoken 用于生成 Token 字符串信息;</span><br>    <span class="hljs-comment">//       express-jwt 用于把 Token 字符串解析为 JSON 对象</span><br><span class="hljs-comment">// --------------------------------------------------------------------------------</span><br>    <span class="hljs-comment">// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt</span><br>    <span class="hljs-comment">// jsonwebtoken 这个包是 加密生成 token 令牌</span><br>        <span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><br>    <span class="hljs-comment">// express-jwt 这个包是负责把 请求头中的 token 解密出来</span><br>        <span class="hljs-keyword">const</span> jwtParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br><span class="hljs-comment">// --------------------------------------------------------------------------------</span><br><span class="hljs-comment">// 2 定义 secret 秘钥</span><br><span class="hljs-comment">// 为了保证 jwt 字符串的安全，防止 jwt 字符串在网络传输中被人破解，我们需要专门定义一个用于加密和解密的 secret 密钥</span><br><span class="hljs-comment">// 当我们生成 jwt 字符串的时候，需要使用 secret 密钥对用的信息进行加密，最终得到加密好的 jwt 字符串</span><br><span class="hljs-comment">// 当把 jwt 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密</span><br><span class="hljs-comment">// 定义 secret 秘钥</span><br><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;itheima No1 ^_^&#x27;</span><br><span class="hljs-comment">// --------------------------------------------------------------------------------</span><br><span class="hljs-comment">// 登录成功</span><br>    <span class="hljs-comment">// TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端</span><br>    <span class="hljs-comment">// 使用 jwt 包提供的 sign 方法, 这个方法要接收三个参数</span><br>    <span class="hljs-comment">// 参数1 用户的信息对象, 这里是 &#123; username: userinfo.username &#125;</span><br>    <span class="hljs-comment">// 参数2 加密的密钥 secretKey 前面定义的密钥的名称</span><br>    <span class="hljs-comment">// 参数3 配置对象，可以配置当前 token 的有效期 &#123; expiresin: &#x27;30s&#x27; &#125; 有效期为 30s，30s后这个 token 将失效</span><br>    <span class="hljs-comment">// 注意,这里只把用户名加密到了 token, 千万不要把密码加密到 token 中，否则会很危险</span><br>    <span class="hljs-keyword">const</span> str = jwt.sign(&#123; <span class="hljs-attr">username</span>: userinfo.username &#125;, secretKey, &#123; <span class="hljs-attr">expiresin</span>: <span class="hljs-string">&#x27;30s&#x27;</span> &#125;)<br><span class="hljs-comment">// --------------------------------------------------------------------------------</span><br><span class="hljs-comment">// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件</span><br><span class="hljs-comment">// app.use()注册中间件</span><br><span class="hljs-comment">// expressJWT()这个中间件来解密 token 密钥</span><br><span class="hljs-comment">// 配置对象 &#123; secret: secretKey &#125; secert 这个属性用来指定解密的密钥 用 secretKey 密钥来解密密钥 secretKey 就是我们定义的密钥名称</span><br><span class="hljs-comment">// 新的 jwt 需要手动指定算法，不然会报错 为 algorithms 属性指定算法即可 algorithms: [&quot;HS256&quot;] 算法</span><br><span class="hljs-comment">// 在 .unless()方法里面指定一个配置对象，配置对象里面有一个path属性，来指定哪些接口不需要访问权限</span><br><span class="hljs-comment">// path 里面写一个数组，数组里是正则表达式，来匹配出不需要访问权限的接口(比如登录页面，不需要权限，任何用户都可以访问)</span><br>app.use(expressJWT(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).unless(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;)) <span class="hljs-comment">//凡是以 /api 开头的，都不需要访问权限</span><br><span class="hljs-comment">// 当我们的 express-jwt这个中间件配置成功以后，即可在那些有权限的接口中，使用 req.user对象，来访问从 JWT 字符串中解析出来的用户信息了</span><br><br><span class="hljs-comment">// --------------------------------------------------------------------------------</span><br><span class="hljs-comment">// 利用 postman 来试验</span><br><span class="hljs-comment">// 1.先发送一个 post 请求，地址就是登陆的地址 http://127.0.0.1:8888/api/login (是不需要访问权限的)</span><br><span class="hljs-comment">// 在Body里面发送 x-www-form-urlencoded 格式的请求 输入用户名 username: admin 和密码 password: 000000</span><br><span class="hljs-comment">// 然后就会获得一串加密后的 token 字符串 因为设定了有效期30s，所以这个 token 字符串，30s 后就失效了</span><br>&#123;<br>    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;登录成功！&quot;</span>,<br>    <span class="hljs-string">&quot;token&quot;</span>: <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNjE0Mzk2MTMyLCJleHAiOjE2MTQzOTYxNjJ9.JfJBIXndzF_aTYbTliJx7AB5mI75Fb2YGGl2R9dQjM0&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 2.发送 get 请求 获取 token 令牌对应的用户数据</span><br><span class="hljs-comment">// get 请求的地址为 http://127.0.0.1:8888/admin/getinfo (这是一个需要 token 权限的接口)</span><br><span class="hljs-comment">// 发送 get 请求的时候，需要一个认证的请求头</span><br><span class="hljs-comment">// 在 Headers 里面发送一个请求头 Authorization 这个请求头的值为刚才获得的加密的 token 字符串(一定要快，只有 30s 有效期)</span><br><span class="hljs-comment">// 在值前面加上一个固定的 Bearer , (固定写法)</span><br><span class="hljs-comment">//  然后点击 send 发送请求, 获得当前用户的信息</span><br>&#123;<br>    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;获取用户信息成功！&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>        <span class="hljs-string">&quot;iat&quot;</span>: <span class="hljs-number">1614397945</span>,<br>        <span class="hljs-string">&quot;exp&quot;</span>: <span class="hljs-number">1614397975</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在生成 token 的是，填充了什么属性，最终解析出来的，就是这个属性和值，</span><br><span class="hljs-comment">// 然后我们可以在有权限的接口中，来访问到解析出来的用户信息，不要填密码，否则会被解析出来</span><br><span class="hljs-comment">// 注意：其中 lat 与 exp 为token的有效期设置，不用管</span><br><span class="hljs-comment">// 使用 req.user 获取用户信息</span><br><span class="hljs-comment">// 这是一个有权限的 API 接口</span><br>app.get(<span class="hljs-string">&#x27;/admin/getinfo&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-comment">// TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端</span><br>    <span class="hljs-built_in">console</span>.log(req.user);<br><br>    res.send(&#123;<br>        status: <span class="hljs-number">200</span>,<br>        message: <span class="hljs-string">&#x27;获取用户信息成功！&#x27;</span>,<br>        data: req.user, <span class="hljs-comment">// 要发送给客户端的用户信息</span><br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// --------------------------------------------------------------------------------</span><br><span class="hljs-comment">// 捕获错误问题</span><br><span class="hljs-comment">// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误</span><br><span class="hljs-comment">// 当我们使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或者不合法，会产生一个解析失败的错误</span><br><span class="hljs-comment">// 影响项目的正常运行，我们可以通过 Express 错误中间件，捕获这个错误并且进行相关的处理</span><br>app.use(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果错误条件成立，说明这次错误是由于 token 解析失败导致的 (不合法或者过期了)</span><br>    <span class="hljs-comment">// UnauthorizedError</span><br>    <span class="hljs-keyword">if</span> (err.name === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> res.send(&#123;<br>            status: <span class="hljs-number">401</span>,<br>            message: <span class="hljs-string">&#x27;无效的token！&#x27;</span><br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 如果错误条件不成立，说明这次错误是未知的</span><br>    res.send(&#123;<br>        status: <span class="hljs-number">500</span>,<br>        message: <span class="hljs-string">&#x27;未知的错误！&#x27;</span><br>    &#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql查询语句</title>
    <link href="/2021/02/24/mysql/"/>
    <url>/2021/02/24/mysql/</url>
    
    <content type="html"><![CDATA[<hr><p>MySQl查询语句大全<br>综合使用 查询 目录：<br>#—-综合使用<br>书写顺序<br>select distinct * from ‘表名’ where ‘限制条件’  group by ‘分组依据’ having ‘过滤条件’ order by  limit ‘展示条数’<br>执行顺序<br>from       – 查询<br>where      – 限制条件<br>group by   – 分组<br>having     – 过滤条件<br>order by   – 排序<br>limit      – 展示条数<br>distinct   – 去重<br>select     – 查询的结果<br>正则：select * from emp where name regexp ‘^j.*(n|y)$’;<br>集合查询：max 、min 、avg 、sum 、count 、group_concat 。<br>内连接：inner join<br>左连接：left join<br>右连接：right join<br>全连接： 左连接 union 右连接<br>replace 替换</p><p>拼接：concat、concat_ws、group_concat<br>常规设置操作<br>1.服务器设置远程访问<br>grant all privileges on <em>.</em> to ‘root’@’%’ identified by ‘123456’ with grant option;<br>2.Linux中数据库的基本操作命令<br>1.使用service<br>  启动：service mysql start<br>  停止：service mysql stop<br>  重启：service mysql restart<br>2.清屏：clear,reset<br>3.备份数据库<br>#mysqldump -uroot -p密码 数据库名 &gt; D:/备份文件名.sql<br>4.恢复备份的数据库<br>#首先在mysql里建好数据库名<br>#mysql -uroot -p密码 数据库名 &lt; D:/备份文件名.sql<br>5.查询binlog日志是否开启<br>show variables like ‘log_%’;<br>基本操作：<br>1.单表约束<br>#主键约束：PRIMARY KEY              要求被装饰的字段：唯一和非空<br>#唯一约束：UNIQUE               要求被装饰的字段：唯一，<br>                           .联合唯一：在结尾：unique(字段1，字段2)<br>#非空约束：NOT NULL             要求被装饰的字段：非空<br>#外键约束：FOREIGN KEY          某主表的外键<br>#自动增加：AUTO_INCREMENT       自动增加(需要和主键 PRIMARY KEY 同时用)<br>#设置默认值:DEFAULT             为该属性设置默认值<br>在int、char中：zerofill            不足位数默认填充0</p><p>2.常用数据类型<br>int        #整型，4个字节  一般不需要指定宽度，（8）：只是显示为8位，默认有负号设置无负号： unsigned<br>double     #浮点型，例如double(5,2),标识最多5位，其中2位为小数，即最大为999.99<br>varchar        #可变长度字符串类型。例如：varchar(10) ‘aaa’ 占3位<br>char       #固定长度字符串类型。例如：char(10) ‘aaa’ 占10位<br>text       #大文本字符串类型。<br>blob       #字节类型。例如：<br>datetime   #日期时间类型。例如：datetime(yyyy-MM-dd hh:mm:ss)<br>date       #日期类型。例如：date(yyyy:MM:dd)<br>time       #时间类型。例如：time(hh:mm:ss)<br>timestamp  #时间戳类型。例如：timestamp(yyyy-MM-dd hh:mm:ss)  会自动赋值<br>enum       #枚举 多选一 enum(‘male’,’female’)，default为默认值<br>例如：sex enum(‘male’,’female’) not null default ‘male’<br>set            #集合 多选多,可以选一个 set（’read’,’DJ’,’DBJ’,’run’)<br>注：字符串类型和时间类型都要用单引号括起来，空值为null<br>3.查看数据列表<br>show databases; – 查看所有数据库<br>show create table 表名; – 查看表的创建细节<br>desc 表名; – 查看表结构<br>4.进入数据库<br>#use 数据名<br>use Python_7<br>5.创建数据库<br>#CREATE DATABASE 数据库名<br>CREATE DATABASE Python_7;<br>CREATE DATABASE pyrhon_7 charset utf8</p><p> 修改数据库编码<br>alter database db1 charset gbk;<br>6.删除数据库<br>#drop database 需要删除的数据库名<br>drop database Python_7;<br>7.查看表<br>select database();  # 查看当前所在的库<br>show tables; – 查看数据库中所有表<br>desc 表名; – 查看表结构<br>show create table 表名; – 查看表的创建细节<br>8.创建表<br> 创建新表<br>create table 新建数据表名（<br>      字段名 类型(长度) [约束(具体见1)],<br>      字段名 类型(长度) [约束(具体见1)]<br> );<br>create table class(<br>      id INT AUTO_INCREMENT,<br>  name varchar(32) UNIQUE,<br>  age varchar(32) NOT NULL<br>);</p><p>#需要注意</p><p>#根据已有的表创建新表<br>create table 新表 like 旧表  – 使用旧表创建新表<br>create table 新表 as select 字段1 字段2… from definition only – 使用自定义值去新建表<br>9.删除表<br>#drop table 数据库表名<br>drop table Python<br>10.修改表<br>alter table 表名 add 字段名 类型（长度） [约束]; – 添加列<br>alter table 表名 modify 字段名 类型（长度） [约束]; – 修改列的类型长度及约束<br>alter table 表名 change 旧字段名 新字段名 类型（长度） [约束]; – 修改列表名<br>alter table 表名 drop 字段名; – 删除列<br>alter table 表名 character set 字符集; – 修改表的字符集<br>rename table 表名 to 新表名; – 修改表名<br>11.增加数据<br>insert into 表(字段名1，字段名2..) values(值1，值2..);– 向表中插入某些列<br>insert into 表 values(值1，值2，值3..); – 向表中插入所有列<br>12.修改数据<br>update 表名 set 字段名=值,字段名=值…; – 这个会修改所有的数据，把一列的值都变了<br>update 表名 set 字段名=值,字段名=值… where 条件; – 只改符合where条件的行<br>13.删除数据<br>delete from 表名  – 删除表中所有记录<br>delete from 表名 where 条件 – 删除符合 where条件的数据<br>truncate table 表名; – 把表直接drop掉，重新建表，auto_increment将置为零。删除的数据不能找回。执行速度比delete快<br>14.数据的简单查询<br>select * from 表名; – 查询所有列<br>select 字段名1,字段名2,字段名3.. from 表名; – 查询指定列<br>15.几个简单的基本的sql语句<br>select * from 表名 where 范围                           – 选择查询<br>insert into 表名(field1,field2) values(value1,value2)   – 插入<br>delete from 表名 where 范围                             – 删除<br>update 表名 set field1=value1 where 范围                – 更新<br>select * from 表名 where field1 like ’%value1%’            – 查找<br>select * from 表名 order by field1,field2 [desc]        – 排序：<br>select count as 需要统计总数的字段名 from 表名             – 总数<br>select sum(field1) as sumvalue from 表名               – 求和<br>select avg(field1) as avgvalue from 表名               – 平均<br>select max(field1) as maxvalue from 表名               – 最大<br>select min(field1) as minvalue from 表名               – 最小<br>16.存储引擎<br> 查看所有的存储引擎<br>show engines;</p><p>查看不同存储引擎存储表结构文件特点<br>create table t1(id int)engine=innodb; – MySQL默认的存储引擎,支持事务,支持行锁，支持外键。有且只有一个主键，用来组织数据的依据<br>create table t2(id int)engine=myisam; – 不支持事务，不支持外键，支持全文索引，处理速度快。<br>create table t3(id int)engine=blackhole; – 黑洞，写入它的任何内容都会消失<br>create table t4(id int)engine=memory;– 将表中的数据存储在内存中。表结构以文件存储于磁盘。</p><p>insert into t1 values(1);<br>insert into t2 values(1);<br>insert into t3 values(1);<br>insert into t4 values(1);</p><p>17.设置严格模式<br>查询<br>show variables like ‘%mode%’;<br>设置<br>set session – 设置当前窗口下有效<br>set global  – 全局有效，终身受用<br>set global sql_mode = “STRICT_TRANS_TABLES”;<br>设置完成后需要退出客户端，重新登录客户端即可，不需要重启服务端</p><p>group by分组涉及到的模式：<br>设置sql_mode为only_full_group_by，意味着以后但凡分组，只能取到分组的依据，<br>不应该在去取组里面的单个元素的值，那样的话分组就没有意义了，因为不分组就是对单个元素信息的随意获取<br>“””<br>set global sql_mode=”strict_trans_tables,only_full_group_by”;<br>重新链接客户端<br>18.like 的用法<br>A:% 包含零个或多个字符的任意字符串：<br>1、like’Mc%’ 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。<br>2、like’%inger’ 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。<br>3、like’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。</p><p>B:_（下划线） 任何单个字符：<br>  like’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。</p><p>C：[ ] 指定范围 ([a-f]) 或集合 ([abcdef]) 中的任何单个字符：<br>  1，like’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。<br>  2、like’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。</p><p>D：[^] 不属于指定范围 ([a-f]) 或集合 ([abcdef]) 的任何单个字符：<br>  like’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。</p><p>E：* 它同于DOS命令中的通配符，代表多个字符：<br>  c*c代表cc,cBc,cbc,cabdfec等多个字符。</p><p>F：？同于DOS命令中的？通配符，代表单个字符 :<br>  b?b代表brb,bFb等</p><p>G：# 大致同上，不同的是代只能代表单个数字。k#k代表k1k,k8k,k0k 。</p><p>下面我们来举例说明一下：</p><p>例1，查询name字段中包含有“明”字的。<br>select * from table1 where name like ‘%明%’</p><p>例2，查询name字段中以“李”字开头。<br>select * from table1 where name like ‘李*’</p><p>例3，查询name字段中含有数字的。<br>select * from table1 where name like ‘%[0-9]%’</p><p>例4，查询name字段中含有小写字母的。<br>select * from table1 where name like ‘%[a-z]%’</p><p>例5，查询name字段中不含有数字的。<br>select * from table1 where name like ‘%[!0-9]%’</p><p>以上例子能列出什么值来显而易见。但在这里，我们着重要说明的是通配符“*”与“%”的区别。</p><p>很多朋友会问，为什么我在以上查询时有个别的表示所有字符的时候用”%”而不用“<em>”？先看看下面的例子能分别出现什么结果：<br>select * from table1 where name like ‘*明</em>‘<br>select * from table1 where name like ‘%明%’<br>大家会看到，前一条语句列出来的是所有的记录，而后一条记录列出来的是name字段中含有“明”的记录，所以说，当我们作字符型字段包含一个子串的查询时最好采用“%”而不用“<em>”,用“</em>”的时候只在开头或者只在结尾时，而不能两端全由“*”代替任意字符的情况下。<br>高级查询操作<br>1、外键表创建<br>一对多（Foreign Key）<br> foreign key(需要关联的本字段) references 需要关联对表的表(需要关联对表的字段)<br>例如：<br>创建dep<br>foreign key(dep_id) references dep(id)<br> 同步更新，同步删除<br>on update cascade #同步更新<br>on delete cascade #同步删除<br>2、表复制<br>复制表<br>create table t1 select * from test;<br>只复制表结构<br>create table t1 select * from test where 1=2;<br>3、单表查询查询<br>0.综合使用<br>#—-综合使用<br>书写顺序<br>select distinct * from ‘表名’ where ‘限制条件’  group by ‘分组依据’ having ‘过滤条件’ order by  limit ‘展示条数’<br>执行顺序<br>from       – 查询<br>where      – 限制条件<br>group by   – 分组<br>having     – 过滤条件<br>order by   – 排序<br>limit      – 展示条数<br>distinct   – 去重<br>select     – 查询的结果</p><p>正则：select * from emp where name regexp ‘^j.*(n|y)$’;<br>集合查询：max 、min 、avg 、sum 、count 、group_concat 。<br>拼接：concat、concat_ws、group_concat<br>内连接：inner join<br>左连接：left join<br>右连接：right join<br>全连接： 左连接 union 右连接<br>1.where 查询<br>between 在…之间<br>select id,name from emp where id &gt;= 3 and id &lt;= 6;<br>相当于：<br>select *  from emp where id between 3 and 6;  </p><p> or 或者<br>select *  from emp where id &gt;= 3 or id &lt;= 6;</p><p>in，后面可以跟多个值<br>select * from 表名 where 字段名 in (条件1,条件2,条件三);<br> like （见上18）<br>char——length()  取字符长度<br>select * from 表名 where char_length(需要获取长度的字段名) = 4;</p><p>not 配合使用<br>注意：判断空不能用 = ，只能用 is<br>2.group by 分组<br>select 查询字段1,查询字段2,… from 表名<br>      where 过滤条件<br>      group by分组依据  # 分组后取出的是每个组的第一条数据<br>3.聚合查询 ：以组为单位统计组内数据&gt;&gt;&gt;聚合查询(聚集到一起合成为一个结果)<br>max 最大值<br> 每个部门的最高工资<br>select post,max(salary) from emp group by post;</p><p>min 最小值<br> 每个部门的最低工资<br>select post,min(salary) from emp group by post;</p><p> avg 平均值<br>每个部门的平均工资<br>select post,avg(salary) from emp group by post;<br> 每个部门的工资总和</p><p>sum 求和<br>select post,sum(salary) from emp group by post;</p><p>count（需要计数字段） 计数<br> 每个部门的人数<br>select post,count(id) from emp group by post;</p><p>group_concat(需要分组后的字段) # 不仅可以用来显示除分组外字段还有拼接字符串的作用<br>  select post,group_concat(name) from emp group by post;<br>  – post：分组字段，name 需要分组后显示的字段<br>拼接：<br>  concat（不分组时用）拼接字符串达到更好的显示效果 as语法使用<br>  举例：<br>      select concat(“NAME: “,name) as 姓名 from emp;<br>  concat_ws: 如果拼接的符号是统一的可以用<br>  举例：<br>      select concat_ws(‘:’,name,age,sex) as info from emp;<br>  group_concat：<br>  举例：<br>      select post,group_concat(name,’DSB’) from emp group by post;</p><p>补充：as语法 起别名<br>select name as 姓名,salary as 薪资 from emp;<br>4.having 过滤查询<br>having的语法格式与where一致，只不过having是在分组之后进行的过滤，即where虽然不能用聚合函数，但是having可以！</p><p>用法<br>select 查询字段1,查询字段2,… from 表名<br>      where 过滤条件1<br>      group by分组依据<br>having avg(过滤条件2) &gt; 10000;<br>5.distinct 去重<br>对有重复的展示数据进行去重操作<br>select distinct 需取重字段 from 表名;<br>6.order by 排序<br>select * from emp order by salary asc; #默认升序排<br>select * from emp order by salary desc; #降序排</p><p>#多条件排序<br>#先按照age降序排，在年轻相同的情况下再按照薪资升序排<br>select * from emp order by age desc,salary asc;<br>7.limit 限制展示条数<br>限制展示条数<br>select * from emp limit 3;<br>查询工资最高的人的详细信息<br>select * from emp order by salary desc limit 1;</p><p> 分页显示<br>select * from emp limit 0,5;  # 第一个参数表示起始位置，第二个参数表示的是条数，不是索引位置<br>select * from emp limit 5,5;<br>8.正则<br>select * from emp where name regexp ‘^j.*(n|y)$’;<br>9.replace 替换<br>replace(str1,old,new) – str1：需要替换的字段名<br>update gd_km set mc=replace（mc,’土地’,’房子’）<br>说明：new替换str1中出现的所有old，返回新的字符串，如果有某个参数为NULL，此函数返回NULL<br>该函数可以多次替换，只要str1中还有old存在，最后都被替换成new<br>若new为空，则删除old<br>四、多表查询<br>1.内连接、左连接、右连接、全连接<br>1、内连接：只取两张表有对应关系的记录（只拼两个表共有的）<br>左表 inner join 右表 on 条件<br>  select * from emp inner join dep on emp.dep_id = dep.id<br>       where dep.name = “技术”;</p><p>2、左连接：在内连接的基础上，保留左边的数据，右边没有就为空<br>左表 inner left 右表 on 条件<br>3、右连接：在内连接的基础上，保留右边的数据，左边没有就为空<br>左表 inner right 右表 on 条件<br>4、全连接：左右连接都有，用union连接<br>左表 inner left 右表 on 条件 union 左表 inner right 右表 on 条件<br>select * from emp left join dep on emp.dep_id = dep.id<br>union<br>select * from emp right join dep on emp.dep_id = dep.id;<br>2.子查询<br>就是将一个查询语句的结果用括号括起来当作另外一个查询语句的条件去用<br>select name from where id in(select dep_id from emp where age&gt;25);</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/21/xc/"/>
    <url>/2021/02/21/xc/</url>
    
    <content type="html"><![CDATA[<p>Node.js模块机制采用了Commonjs规范，弥补了当前JavaScript开发大型没有标准的缺陷，类似于Java中的类文件，Python中的import机制，NodeJs中可以通过module.exports、require来导出和引入一个模块.</p><p>在模块加载机制中，NodeJs采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到binding_cache中。</p><p>推荐技术博客: Node.js技术栈</p><p>快速导航<br>模块的分类<br>系统模块<br>第三方模块<br>目录结构<br>模块加载机制<br>模块循环引用<br>exports与module.exports的区别<br>面试指南<br>require的加载机制？，参考：模块加载机制<br>module.exports与exports的区别，参考：module.exports与exports的区别<br>假设有a.js、b.js两个模块相互引用，会有什么问题？是否为陷入死循环？，参考：#<br>a模块中的undeclaredVariable变量在b.js中是否会被打印？，参考：#<br>模块的分类<br>系统模块<br>C/C++模块，也叫built-in内建模块，一般用于native模块调用，在require出去</p><p>native模块，在开发中使用的Nodejs的http、buffer、fs等，底层也是调用的内建模块(C/C++)。</p><p>第三方模块<br>这里非Nodejs自带的模块称为第三方模块，其实还分为路径形式的文件模块（以.、..、/开头的）和自定义的模块（比如express、koa框架、moment.js等）</p><p>javaScript模块：例如hello.js</p><p>json模块：例如hello.json</p><p>C/C++模块：编译之后扩展名为.node的模块，例如hello.node</p><p>目录结构<br>├── benchmark                         一些nodejs性能测试代码<br>├── deps                              nodejs依赖<br>├── doc                               文档<br>├── lib                               nodejs对外暴露的js模块源码<br>├── src                               nodejs的c/c++源码文件，内建模块<br>├── test                              单元测试<br>├── tools                             编译时用到的工具<br>├── doc                               api文档<br>├── vcbuild.bat                       win平台makefile文件<br>├── node.gyp                          node-gyp构建编译任务的配置文件<br>…<br>模块加载机制<br>面试中可能会问到能说下require的加载机制吗?</p><p>在Nodejs中模块加载一般会经历3个步骤，路径分析、文件定位、编译执行。</p><p>按照模块的分类，按照以下顺序进行优先加载：</p><p>系统缓存：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值。</p><p>系统模块：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了路径分析、文件定位，直接加载到了内存中，系统模块定义在Node.js源码的lib目录下，可以去查看。</p><p>文件模块：优先加载.、..、/开头的，如果文件没有加上扩展名，会依次按照.js、.json、.node进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在，从性能优化的角度来看待，.json、.node最好还是加上文件的扩展名。</p><p>目录做为模块：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个包来处理，Node这块采用了Commonjs规范，先会在项目根目录查找package.json文件，取出文件中定义的main属性(“main”: “lib/hello.js”)描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module ‘lib/hello.js’</p><p>node_modules目录加载：对于系统模块、路径文件模块都找不到，Node.js会从当前模块的父目录进行查找，直到系统的根目录</p><p>图片描述</p><p>require模块加载时序图<br>模块循环引用<br>问题1<br>假设有a.js、b.js两个模块相互引用，会有什么问题？是否为陷入死循环？看以下例子：</p><p>a.js</p><p>console.log(‘a模块start’);</p><p>exports.test = 1;</p><p>undeclaredVariable = ‘a模块未声明变量’</p><p>const b = require(‘./b’);</p><p>console.log(‘a模块加载完毕: b.test值：’,b.test);<br>b.js</p><p>console.log(‘b模块start’);</p><p>exports.test = 2;</p><p>const a = require(‘./a’);</p><p>console.log(‘undeclaredVariable: ‘, undeclaredVariable);</p><p>console.log(‘b模块加载完毕: a.test值：’, a.test);<br>问题2<br>问题2: a模块中的undeclaredVariable变量在b.js中是否会被打印？</p><p>控制台执行node a.js，查看输出结果：</p><p>a模块start<br>b模块start<br>undeclaredVariable:  a模块未声明变量<br>b模块加载完毕: a.test值： 1<br>a模块加载完毕: b.test值： 2<br>问题1，启动a.js的时候，会加载b.js，那么在b.js中又加载了a.js，但是此时a.js模块还没有执行完，返回的是一个a.js模块的exports对象未完成的副本给到b.js模块。然后b.js完成加载之后将exports对象提供给了a.js模块</p><p>问题2，因为undeclaredVariable是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方当然是可以拿到的。</p><p>在执行代码之前，Node.js会使用一个代码封装器进行封装，例如下面所示：</p><p>(function(exports, require, module, __filename, __dirname) {<br>// 模块的代码<br>});<br>exports与moduleexports的区别<br>exports与module.exports的区别<br>exports相当于module.exports 的快捷方式如下所示:</p><p>const exports = modules.exports;<br>但是要注意不能改变exports的指向，我们可以通过 exports.test = ‘a’ 这样来导出一个对象, 但是不能向下面示例直接赋值，这样会改变exports的指向</p><p>//错误的写法 将会得到undefined<br>exports = {<br>  ‘a’: 1,<br>  ‘b’: 2<br>}</p><p>//正确的写法<br>modules.exports = {<br>  ‘a’: 1,<br>  ‘b’: 2<br>}</p><p>作者：五月君<br>链接：<a href="https://www.imooc.com/article/284624">https://www.imooc.com/article/284624</a><br>来源：慕课网<br>本文首次发布于慕课网 ，转载请注明出处，谢谢合作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm命令</title>
    <link href="/2021/02/21/npm/"/>
    <url>/2021/02/21/npm/</url>
    
    <content type="html"><![CDATA[<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> -l 查看所有命令的用例信息<br><span class="hljs-built_in">npm</span> help 查看某个命令的帮助信息<br><span class="hljs-built_in">npm</span> help-search 在帮助文档中查找包含关键词的文档列表<br><span class="hljs-built_in">npm</span> -h 查看某个命令的用法<br><span class="hljs-built_in">npm</span> root [-g] 查看本地或者全局node-<span class="hljs-built_in">module</span>目录的位置<br><span class="hljs-built_in">npm</span> ping 验证registry的连通性和身份验证<br><br><span class="hljs-built_in">npm</span> init 初始化当前目录为一个包，会生成一个 package.json 的文件<br><br><span class="hljs-built_in">npm</span> install 不带任何参数，会按照根目录下的package.json里的依赖包<br><span class="hljs-built_in">npm</span> install [&lt;@scope&gt;/] 局部安装某个包<br><span class="hljs-built_in">npm</span> install [&lt;@scope&gt;/]@ 局部安装某个包（按照tag）<br><span class="hljs-built_in">npm</span> install [&lt;@scope&gt;/]@ 安装包的某个版本<br><span class="hljs-built_in">npm</span> i install的别名<br><span class="hljs-built_in">npm</span> install-test 它和<span class="hljs-built_in">npm</span> install的区别是执行完<span class="hljs-built_in">npm</span> install后立马执行<span class="hljs-built_in">npm</span> test<br><span class="hljs-built_in">npm</span> <span class="hljs-literal">it</span> 同上alias<br><br><span class="hljs-built_in">npm</span> uninstall 卸载某个包<br><span class="hljs-built_in">npm</span> un 同上，别名<br><br><span class="hljs-built_in">npm</span> update [-g] […] 更新包<br><span class="hljs-built_in">npm</span> up [-g] […] <span class="hljs-built_in">npm</span> update的别名<br><br><span class="hljs-built_in">npm</span> link [&lt;@scope&gt;/][@] 将<span class="hljs-built_in">npm</span>包创建快捷方式到全局<span class="hljs-built_in">npm</span>的路径下<br><br><span class="hljs-built_in">npm</span> outdated 查看当前安装的包里版本是否过期的信息<br><br><span class="hljs-built_in">npm</span> deprecate [@] 添加对某个包的某个版本的反对信息。只有owner才可以，安装此包能看到这些反对信息<br><br><span class="hljs-built_in">npm</span> pack 将当前<span class="hljs-built_in">npm</span>包文件打成一个压缩包<br><br><span class="hljs-built_in">npm</span> prune 移除没有定义在package.json 依赖配置上的包<br><br><span class="hljs-built_in">npm</span> search [–long] [search terms …] 从远程仓库中搜索某个包的信息<br><br><span class="hljs-built_in">npm</span> owner add [&lt;@scope&gt;/] 添加某个用户作为某个包的管理者<br><span class="hljs-built_in">npm</span> owner rm [&lt;@scope&gt;/] 移除某个用户作为某个包的管理者<br><span class="hljs-built_in">npm</span> owner ls [&lt;@scope&gt;/] 查看某个包的管理者<br><br><span class="hljs-built_in">npm</span> config get registry 获取<span class="hljs-built_in">npm</span> 仓库地址<br><span class="hljs-built_in">npm</span> config <span class="hljs-keyword">list</span> [—-json] 获取<span class="hljs-built_in">npm</span>配置信息<br><span class="hljs-built_in">npm</span> config edit 编辑<span class="hljs-built_in">npm</span>的配置信息<br><span class="hljs-built_in">npm</span> config <span class="hljs-keyword">delete</span> 删除某个配置<br><span class="hljs-built_in">npm</span> set key val 设置某个配置<br><span class="hljs-built_in">npm</span> get key val 获取某个配置<br><span class="hljs-built_in">npm</span> c === <span class="hljs-built_in">npm</span> config 别名<br><br><span class="hljs-built_in">npm</span> tag管理,tag的作用是不干扰正常版本发布的前提下，发布一个基于某个tag的版本，下载latest版本是不会下载到这个tag产生的版本。<br><span class="hljs-built_in">npm</span> dist-tag add @ [] 为某个版本添加tag 如果添加的tag为latest，这个tag版本将成为最新版本。用户下载最新的时候会直接下载到该版本<br><span class="hljs-built_in">npm</span> dist-tag rm 移除tag<br><span class="hljs-built_in">npm</span> dist-tag ls [] 查看tag清单<br><br><span class="hljs-built_in">npm</span> cache add 添加某个tar包到缓存<br><span class="hljs-built_in">npm</span> cache add 通过git地址添加某个包到缓存<br><span class="hljs-built_in">npm</span> cache add @ 添加某个包到缓存<br><span class="hljs-built_in">npm</span> cache clean —force 清除缓存文件 <span class="hljs-built_in">npm</span>@<span class="hljs-number">5</span> 后必须使用强制符<br><span class="hljs-built_in">npm</span> cache verify 清理无用的缓存文件和校验缓存数据完整性<br><br><span class="hljs-built_in">npm</span> doctor <span class="hljs-built_in">npm</span>诊断命令，<span class="hljs-built_in">npm</span> 会对<span class="hljs-built_in">npm</span>运行的环境进行检测诊断，包括<span class="hljs-built_in">npm</span>的版本，git版本，<span class="hljs-built_in">npm</span>使用的文件权限，<span class="hljs-built_in">npm</span> ping等等<br><br><span class="hljs-built_in">npm</span> version <span class="hljs-built_in">npm</span> 版本<br><span class="hljs-built_in">npm</span> whoami <span class="hljs-built_in">npm</span> 当前登陆用户<br><br><span class="hljs-built_in">npm</span> adduser 添加用户<br><span class="hljs-built_in">npm</span> login 登陆用户<br><span class="hljs-built_in">npm</span> logout 退出当前登陆的<span class="hljs-built_in">npm</span>账号<br><br><span class="hljs-built_in">npm</span> unpublish [&lt;@scope&gt;/][@] 取消发布包, 将发布的包从远程仓库中删除<br><span class="hljs-built_in">npm</span> publish [|] [–tag ] [–access &lt;public|restricted&gt;] 发布一个包<br><br><span class="hljs-built_in">npm</span> bugs 打开包的bugs 报告页面<br><span class="hljs-built_in">npm</span> docs 打开包的文档地址<br><span class="hljs-built_in">npm</span> repo [] 打开包的源文件管理地址 比如github地址<br><br><span class="hljs-built_in">npm</span> bin [—-<span class="hljs-built_in">global</span>] 查看<span class="hljs-built_in">npm</span> 可执行文件的目录<br><br>查看当前<span class="hljs-built_in">npm</span>包的依赖包列表<br><span class="hljs-built_in">npm</span> ls<br><span class="hljs-built_in">npm</span> <span class="hljs-keyword">list</span><br><span class="hljs-built_in">npm</span> la<br><span class="hljs-built_in">npm</span> ll<br><br><span class="hljs-built_in">npm</span> 用户个人信息管理<br><span class="hljs-built_in">npm</span> profile get [–json|–parseable] [] 获取个人信息<br><span class="hljs-built_in">npm</span> profile set [–json|–parseable] 设置个人信息<br><span class="hljs-built_in">npm</span> profile set password 设置密码<br><span class="hljs-built_in">npm</span> profile enable-<span class="hljs-number">2fa</span> [auth-<span class="hljs-keyword">and</span>-writes|auth-only] 设置开启双重验证<br><span class="hljs-built_in">npm</span> profile disable-<span class="hljs-number">2fa</span> 关闭开启双重验证<br><br><span class="hljs-built_in">npm</span> completion &gt;&gt; ~/.zsh <span class="hljs-built_in">npm</span>开启自动补全命令，设置后，按住tab键能自动提示<span class="hljs-built_in">npm</span> 命令<br><br><span class="hljs-built_in">npm</span> stop 运行当前目录下的package.json 里的scripts里的top命令，如果有的话<br><span class="hljs-built_in">npm</span> start 运行当前目录下的package.json 里的scripts里的start命令，如果有的话<br><span class="hljs-built_in">npm</span> restart 运行当前目录下的package.json 里的scripts里的restart命令，如果没有，则执行<span class="hljs-built_in">npm</span> stop 再执行<span class="hljs-built_in">npm</span> start<br><span class="hljs-built_in">npm</span> run-script [-- …] 运行当前目录下的package.json 里的scripts里的命令<br><span class="hljs-built_in">npm</span> run 同上，别名<br><span class="hljs-built_in">npm</span> test [-- ] 运行当前目录下的package.json 里的scripts里的test命令，如果有的话<br><br><span class="hljs-built_in">npm</span> star […] 将某个包加入当前用户的感兴趣的清单<br><span class="hljs-built_in">npm</span> unstar […] 将某个包移除当前用户清单<br><span class="hljs-built_in">npm</span> stars [] 列出该用户所有感兴趣的包<br><br><span class="hljs-built_in">npm</span> rebuild [[&lt;@scope&gt;/]…] 执行编译某个包<br><span class="hljs-built_in">npm</span> rb 同上，alias<br><br><span class="hljs-built_in">npm</span> prefix [-g] 查看最靠近package.json的父级目录<br><br><span class="hljs-built_in">npm</span> dedupe 通过一些算法 将多个依赖包中重复依赖的包移除，只保留一个<br><span class="hljs-built_in">npm</span> ddp 同上 别名<br><br><span class="hljs-built_in">npm</span> explore [ – ] 进入指定的包里执行一些命令，比如执行更新源代码，执行重新编译等<br><br><span class="hljs-built_in">npm</span> access 设置包的权限<br><span class="hljs-built_in">npm</span> edit 修改包内容<br><br><span class="hljs-built_in">npm</span> team 管理所属团队或者添加团队成员等<br><br><span class="hljs-built_in">npm</span> shrinkwrap 生成当前项目确定的依赖版本，类似package-lock.json，但是还是有略微区别<br><br><span class="hljs-built_in">npm</span> token 身份令牌管理<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级-ES6中常用的方法</title>
    <link href="/2021/02/09/JS%E9%AB%98%E7%BA%A7-day05-ES6%E3%80%81let%E3%80%81const%E3%80%81%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%80%81%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E3%80%81%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81set/"/>
    <url>/2021/02/09/JS%E9%AB%98%E7%BA%A7-day05-ES6%E3%80%81let%E3%80%81const%E3%80%81%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%80%81%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E3%80%81%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81set/</url>
    
    <content type="html"><![CDATA[<p>这里总结ES6新增语法。主要包括let、const、解构赋值、箭头函数等书写格式及方法。拓展了一些相关知识，如剩余参数、拓展运算符、模版字符串、set等。</p><p>ES6 从2015年6月开始发布，每年的6月会正式更新一次，作为当年的正式版本（如ES2016、ES2018）。因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p><h2 id="JS高级-day05"><a href="#JS高级-day05" class="headerlink" title="JS高级 day05"></a>JS高级 day05</h2><h3 id="1-ES6概念"><a href="#1-ES6概念" class="headerlink" title="1. ES6概念"></a>1. ES6概念</h3><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范</p><table><thead><tr><th align="center">年份</th><th align="center">版本</th></tr></thead><tbody><tr><td align="center">2015年6月</td><td align="center">ES2015</td></tr><tr><td align="center">2016年6月</td><td align="center">ES2016</td></tr><tr><td align="center">2017年6月</td><td align="center">ES2017</td></tr><tr><td align="center">2018年6月</td><td align="center">ES2018</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><h3 id="2-ES6-新增语法"><a href="#2-ES6-新增语法" class="headerlink" title="2. ES6 新增语法"></a>2. ES6 新增语法</h3><h4 id="2-1-let（★★★）"><a href="#2-1-let（★★★）" class="headerlink" title="2.1 let（★★★）"></a><strong><span style="color: ; background-color: yellow;">2.1 let（★★★）</span></strong></h4><p>ES6中新增了用于声明变量的关键字</p><h5 id="2-1-1-let-作用"><a href="#2-1-1-let-作用" class="headerlink" title="2.1.1 let 作用"></a>2.1.1 let 作用</h5><p>用来声明一个有块级作用域的变量，使用方法和 var 一样</p><h5 id="2-1-2-let-定义变量的特点"><a href="#2-1-2-let-定义变量的特点" class="headerlink" title="2.1.2 let 定义变量的特点"></a>2.1.2 let 定义变量的特点</h5><ol><li><p>只在声明时的块或子块中可用</p></li><li><p>不存在变量提升，只能先声明再使用</p></li><li><p>存在“暂存死区”</p></li><li><p>同一作用域下不能重复声明同一变量</p></li><li><p>声明的变量不会挂载在 window 对象上 </p></li></ol><h5 id="2-1-3-暂时性死区的本质"><a href="#2-1-3-暂时性死区的本质" class="headerlink" title="2.1.3 暂时性死区的本质"></a>2.1.3 暂时性死区的本质</h5><p> 只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，</p><p> 只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = <span class="hljs-number">20</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">//报错  bar存在当前的块级作用域，但是无法提前访问</span><br>    <span class="hljs-keyword">let</span> bar = <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-const（★★★）"><a href="#2-2-const（★★★）" class="headerlink" title="2.2 const（★★★）"></a><strong><span style="color: ; background-color: yellow;">2.2 const（★★★）</span></strong></h4><p>2.2.1 const 作用</p><p>声明常量，常量就是值（内存地址）不能变化的量</p><p>2.2.1 const 特点</p><ol><li><p>声明常量时必须要初始化值</p><ol start="2"><li><p>同样具有块级作用域和“暂存死区”</p></li><li><p>赋值为简单数据类型时，不能直接修改值</p></li></ol></li><li><p>赋值为复杂数据类型时，可以修改对象内部的属性和方法</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;<br>     a: <span class="hljs-number">1</span>,<br>     b: <span class="hljs-number">2</span><br> &#125;<br>data.a = <span class="hljs-number">10</span> <span class="hljs-comment">//这里可以通过，原因是data的内存地址值没有发生改变</span><br>data=[] <span class="hljs-comment">//这里会报错，原因是data的内存地址值发生了改变</span><br></code></pre></td></tr></table></figure><h4 id="2-3-let-const-var关键字区别"><a href="#2-3-let-const-var关键字区别" class="headerlink" title="2.3 let,const,var关键字区别"></a>2.3 let,const,var关键字区别</h4><p>变量的使用建议：</p><p>（1） 优先使用 const 关键字声明固定不变的量</p><p>（2） 使用 let 关键字声明变化的量</p><p>（3） 兼容性考虑 或 基于 jQuery 的项目使用 var; 基于 vue 的项目 let/const</p><h4 id="2-4-解构赋值（★★★）"><a href="#2-4-解构赋值（★★★）" class="headerlink" title="2.4 解构赋值（★★★）"></a><strong><span style="color: ; background-color: yellow;">2.4 解构赋值（★★★）</span></strong></h4><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构<br>数组解构</p><h5 id="2-4-1-数组解构"><a href="#2-4-1-数组解构" class="headerlink" title="2.4.1 数组解构"></a>2.4.1 数组解构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 对数组进行解构</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> [a, b, c] = arr<br><span class="hljs-built_in">console</span>.log(a, b, c); <span class="hljs-comment">//3 4 5</span><br><br><span class="hljs-comment">// 2. 没有解构成功的变量，值为 undefined</span><br><span class="hljs-keyword">let</span> [a2, b2, c2, d2] = arr<br><span class="hljs-built_in">console</span>.log(d2);<span class="hljs-comment">//undefined</span><br><br><span class="hljs-comment">// 3. 不需要解构的元素可以使用 逗号 隔开</span><br><span class="hljs-keyword">let</span> [, , a1, b1] = arr<br><span class="hljs-built_in">console</span>.log(a1, b1)<span class="hljs-comment">// 4 5</span><br><br><span class="hljs-comment">// 4. 交换两个变量</span><br><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">20</span>;<br>[num1, num2] = [num2, num1] <span class="hljs-comment">//前面分号为了与上行代码隔开(针对无分号写法)</span><br><span class="hljs-built_in">console</span>.log(num1, num2);<br><span class="hljs-comment">// 注意: 无分号写法中, 以 () 或 [] 开头的语句前要加分隔符(! ;)</span><br></code></pre></td></tr></table></figure><h5 id="2-4-2-对象解构"><a href="#2-4-2-对象解构" class="headerlink" title="2.4.2 对象解构"></a>2.4.2 对象解构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = &#123;<br>    id: <span class="hljs-number">1</span>,<br>    name: <span class="hljs-string">&#x27;家电&#x27;</span>,<br>    goods: &#123;<br>        id: <span class="hljs-number">11</span>,<br>        name: <span class="hljs-string">&#x27;洗衣机&#x27;</span>,<br>        goods: &#123;<br>            id: <span class="hljs-number">112</span>,<br>            name: <span class="hljs-string">&#x27;海尔&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取112 和 海尔</span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">goods</span>: &#123;<span class="hljs-attr">goods</span>: &#123;id,name&#125;&#125;&#125; = data<br><span class="hljs-built_in">console</span>.log(name, id);<br></code></pre></td></tr></table></figure><h5 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h5><p>小结</p><ul><li>解构赋值就是把数据结构分解，然后给变量进行赋值</li><li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为 undefined</li><li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用<br>逗号隔开</li><li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li></ul><h4 id="2-5-箭头函数（★★★）"><a href="#2-5-箭头函数（★★★）" class="headerlink" title="2.5 箭头函数（★★★）"></a><strong><span style="color: ; background-color: yellow;">2.5 箭头函数（★★★）</span></strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;&#125; <span class="hljs-comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span><br><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;&#125;<span class="hljs-comment">//代表把一个函数赋值给fn</span><br></code></pre></td></tr></table></figure><ul><li><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p></li><li><p>如果形参只有一个，可以省略小括号</p></li><li><p>箭头函数没有自己的 this, 它里面的 this 指向箭头函数所处位置的 this ⭐⭐⭐</p></li></ul><h4 id="2-6-剩余参数（★★）"><a href="#2-6-剩余参数（★★）" class="headerlink" title="2.6 剩余参数（★★）"></a>2.6 剩余参数（★★）</h4><p>剩余参数使用在解构赋值中, 表示数组中剩余的所有元素 ，或者对象中剩余的所有属性</p><ol><li>把数组中剩下的元素组成新的数组</li><li>把对象剩下的属性组成一个新对象</li><li>使用剩余参数快速实现浅拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getSum = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br>    rest.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> sum += item)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-keyword">const</span> res = getSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">console</span>.log(res);<br><span class="hljs-comment">//使用剩余参数快速实现浅拷贝</span><br><span class="hljs-keyword">const</span> &#123;...obj2&#125; = obj1<br></code></pre></td></tr></table></figure><h3 id="3-ES6的内置对象扩展"><a href="#3-ES6的内置对象扩展" class="headerlink" title="3.ES6的内置对象扩展"></a>3.ES6的内置对象扩展</h3><h4 id="3-1-数组的扩展方法"><a href="#3-1-数组的扩展方法" class="headerlink" title="3.1 数组的扩展方法"></a>3.1 数组的扩展方法</h4><h5 id="扩展运算符（★★）"><a href="#扩展运算符（★★）" class="headerlink" title="扩展运算符（★★）"></a>扩展运算符（★★）</h5><p>拓展运算符（展开语法 或 spred运算符） …对象名 或 …数组名</p><p>作用：把数组或对象转为用逗号分隔的参数形式</p><ul><li>拓展数组</li><li>拓展对象</li><li>将伪数组转为真数组  arr = […spans]  或者Array.from()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">console</span>.log(...arr1);<br></code></pre></td></tr></table></figure><h5 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>      <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>      <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>      length: <span class="hljs-number">2</span><span class="hljs-comment">//必须写</span><br>&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(obj)<br></code></pre></td></tr></table></figure><h5 id="数组find方法"><a href="#数组find方法" class="headerlink" title="数组find方法"></a>数组find方法</h5><p>find 方法用于查找数组中符合条件的第一个元素，返回值: 找到的元素,没找到返回undefined</p><p>类比： filter(所有符合条件的元素)   some(返回布尔值)   indexOf(索引号)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 找出大于 10 的第一个元素</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">44</span>]<br><span class="hljs-keyword">const</span> res = arr.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">10</span>)<br><span class="hljs-built_in">console</span>.log(res);<span class="hljs-comment">//12</span><br></code></pre></td></tr></table></figure><h5 id="数组findIndex方法"><a href="#数组findIndex方法" class="headerlink" title="数组findIndex方法"></a>数组findIndex方法</h5><p>findIndex() 方法用于查找数组中符合条件的第一个元素的索引，返回值是索引值，找不到返回-1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>]<br><span class="hljs-keyword">const</span> res = arr.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h5 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a>实例方法：includes()</h5><p>判断某个数组是否包含给定的值，返回布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="3-2-字符串的扩展"><a href="#3-2-字符串的扩展" class="headerlink" title="3.2 字符串的扩展"></a>3.2 字符串的扩展</h4><p><strong><span style="color: ; background-color: yellow;">模板字符串</span></strong></p><p>ES6新增的创建字符串的方式，使用反引号定义。(强大的字符串变量拼接语法)</p><p>作用：</p><ol><li>使用反引号（``）代替单双引号</li><li>使用 ${变量名或表达式} 代替原来的 ‘引引加加’</li><li>模板字符串支持换行</li><li>在模板字符串中可以放任意的表达式 (如三元表达式, 函数调用, 逻辑运算符, +-*/…)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;456&#x27;</span><br><span class="hljs-keyword">let</span> str3 = <span class="hljs-string">`hello <span class="hljs-subst">$&#123;<span class="hljs-literal">true</span>?<span class="hljs-string">&#x27;abc&#x27;</span>:<span class="hljs-string">&#x27;def&#x27;</span>&#125;</span> <span class="hljs-subst">$&#123;foo()&#125;</span>`</span><br><span class="hljs-built_in">console</span>.log(str3);<span class="hljs-comment">//hello abc 456</span><br></code></pre></td></tr></table></figure><h5 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith() 和 endsWith()"></a>实例方法：startsWith() 和 endsWith()</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>str.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true 表示参数字符串是否在原字符串的头部，返回布尔值</span><br>str.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>)       <span class="hljs-comment">// true 表示参数字符串是否在原字符串的尾部，返回布尔值</span><br></code></pre></td></tr></table></figure><h5 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>)      <span class="hljs-comment">// &quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>)  <span class="hljs-comment">// &quot;hellohello&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-Set数据解构-★★"><a href="#3-3-Set数据解构-★★" class="headerlink" title="3.3 Set数据解构(★★)"></a>3.3 Set数据解构(★★)</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的<br>值。</p><h5 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 向 set 中添加元素 add()</span><br>mySet.add(<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">// 2. 从 set 中删除元素 delete()</span><br>mySet.delete(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 3. 从 set 中查找元素 has()  返回布尔值</span><br><span class="hljs-built_in">console</span>.log(mySet.has(<span class="hljs-number">6</span>)); <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">// 4. 清空所有元素 clear()</span><br>mySet.clear()<br><span class="hljs-built_in">console</span>.log(mySet);<br></code></pre></td></tr></table></figure><h5 id="Set遍历"><a href="#Set遍历" class="headerlink" title="Set遍历"></a>Set遍历</h5><p>1.forEach() 方法遍历 set 数据中的每个元素</p><p>2.for…of 方法遍历任何可迭代的数据( Set, 数组, Map, 字符串)</p><p>注意: 对象不支持直接 for..of 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>])<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet) &#123; <span class="hljs-comment">// 1. 遍历set数据</span><br>     <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>    a: <span class="hljs-number">1</span>,<br>    b: <span class="hljs-number">2</span>,<br>    c: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123; <span class="hljs-comment">//2. 遍历对象</span><br>     <span class="hljs-built_in">console</span>.log(item);<br>     <span class="hljs-built_in">console</span>.log(obj[item]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础-数组和字符串相关方法</title>
    <link href="/2021/02/09/JavaScript%E5%9F%BA%E7%A1%80-day06-%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/02/09/JavaScript%E5%9F%BA%E7%A1%80-day06-%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>总结了一些JS基础里，操作数据和字符串的常用方法。</p><p>其特性和书写方法需要加强记忆，反复练习。</p><h2 id="JS基础-数组的相关方法"><a href="#JS基础-数组的相关方法" class="headerlink" title="JS基础 - 数组的相关方法"></a>JS基础 - 数组的相关方法</h2><table><thead><tr><th align="left">方法名</th><th>作用</th><th>参数</th><th>返回值</th><th>修改原数组</th></tr></thead><tbody><tr><td align="left"><strong>★push(n1, n2)</strong></td><td>追加元素到数组末尾</td><td>要追加的元素</td><td>加过的数组长度</td><td>修改</td></tr><tr><td align="left"><strong>unshift(n1, n2)</strong></td><td>追加元素到数组开头</td><td>要追加的元素</td><td>加过的数组长度</td><td>修改</td></tr><tr><td align="left"><strong>Array.isArray()</strong></td><td>判断一个值是否是数组</td><td>值或变量</td><td>布尔值</td><td>–</td></tr><tr><td align="left"><strong>pop()</strong></td><td>从数组末尾删除一个元素</td><td>无</td><td>删除的元素</td><td>修改</td></tr><tr><td align="left"><strong>shift()</strong></td><td>从数组开头添加一个元素</td><td>无</td><td>删除的元素</td><td>修改</td></tr><tr><td align="left"><strong>sort(fn)</strong></td><td>对数组进行排序</td><td>函数</td><td>排序后的数组</td><td>修改</td></tr><tr><td align="left"><strong>reverse()</strong></td><td>对数组进行翻转</td><td>无</td><td>翻转后的数组</td><td>修改</td></tr><tr><td align="left"><strong>★indexOf(元素)</strong></td><td>查找元素在数组中第一次出现的索引</td><td>要查找的元素</td><td>索引值 ( - 1)</td><td>不会修改</td></tr><tr><td align="left"><strong>lastIndexOf(元素)</strong></td><td>从后向前查找元素在数组中出现的索引</td><td>要查找的元素</td><td>索引值 ( - 1)</td><td>不会修改</td></tr><tr><td align="left"><strong>★join(连接符)</strong></td><td>把数组中元素连接并返回字符串</td><td>连接符</td><td>字符串</td><td>不会修改</td></tr><tr><td align="left"><strong>toString()</strong></td><td>把复杂数据类型转成字符串形式</td><td>无</td><td>字符串</td><td>不会修改</td></tr><tr><td align="left"><strong>★slice(m[, n])</strong></td><td>从m位置开始截取数组到n结束</td><td>索引值</td><td>新数组</td><td>不会修改</td></tr><tr><td align="left"><strong>★splice(m, n)</strong></td><td>从m位置开始删除数组, 删除n个</td><td>(索引, 个数)</td><td>删除元素的新数组</td><td>会修改</td></tr><tr><td align="left"><strong>concat(arr1, arr2)</strong></td><td>拼接两个或多个数组</td><td>要拼接的数组</td><td>拼接后的新数组</td><td>不会修改</td></tr></tbody></table><h2 id="JS-基础-字符串的相关方法"><a href="#JS-基础-字符串的相关方法" class="headerlink" title="JS 基础 - 字符串的相关方法"></a>JS 基础 - 字符串的相关方法</h2><table><thead><tr><th>方法名</th><th>作用</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><strong>length</strong></td><td>获取字符串的长度</td><td>无</td><td>字符串的长度</td></tr><tr><td><strong>★str[i]</strong></td><td>获取指定索引位置的字符</td><td>无</td><td>单个字符</td></tr><tr><td><strong>charAt(i)</strong></td><td>获取指定索引位置的字符</td><td>索引</td><td>单个字符</td></tr><tr><td><strong>★indexOf(字符[, n])</strong></td><td>从位置 n 开始查找字符的索引位置</td><td>字符</td><td>索引值 (-1)</td></tr><tr><td><strong>lastIndexOf(字符)</strong></td><td>从后向前查找字符出现的索引位置</td><td>字符</td><td>索引值 (-1)</td></tr><tr><td><strong>★slice(m[, n])</strong></td><td>从 m 位置开始截取字符串, 截止到 n 位置</td><td>索引</td><td>截取后的字符</td></tr><tr><td><strong>★substr(m[, n])</strong></td><td>从 m 位置开始截取字符串, 截取 n 位数</td><td>索引</td><td>截取后的字符</td></tr><tr><td><strong>substring(m[, n])</strong></td><td>从 m 位置开始截取字符串, 截止到 n 位置</td><td>索引</td><td>截取后的字符</td></tr><tr><td><strong>★split(分隔符)</strong></td><td>把字符串按照指定的分隔符分隔成数组</td><td>分隔符</td><td>新数组</td></tr><tr><td><strong>toUpperCase()</strong></td><td>把字符串中的小写字母转大写</td><td>无</td><td>转化后的字符串</td></tr><tr><td><strong>toLowerCase()</strong></td><td>把字符串中的大写字母转小写</td><td>无</td><td>转化后的字符串</td></tr></tbody></table><p><strong>备注:</strong><br>字符串中所有的方法都不会修改原本的字符串, 要想修改只能重新赋值;</p><p>重点记忆★的相关方法</p>]]></content>
    
    
    <categories>
      
      <category>JS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级-正则表达式</title>
    <link href="/2021/02/09/Javascript%E9%AB%98%E7%BA%A7-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/02/09/Javascript%E9%AB%98%E7%BA%A7-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在<br>JavaScript中，正则表达式也是对象。<br>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户<br>名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，<br>正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要<br>的特定部分(提取)等 。<br>在其他语言也会使用正则表达式，因此有很学习的必要。</p><h2 id="JS高级-day04-正则表达式"><a href="#JS高级-day04-正则表达式" class="headerlink" title="JS高级 day04-正则表达式"></a>JS高级 day04-正则表达式</h2><h3 id="1-正则表达式概述"><a href="#1-正则表达式概述" class="headerlink" title="1.正则表达式概述"></a>1.正则表达式概述</h3><h4 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h4><p>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式，在数据类型中是属于对象</p><h4 id="1-2作用及特点"><a href="#1-2作用及特点" class="headerlink" title="1.2作用及特点"></a>1.2作用及特点</h4><ul><li><p>作用：正则表达式通常用来校验、查找、替换指定规则的字符文本</p><ol><li><p>验证表单，如：只能输入英文、字母、数字和下划线</p><ol start="2"><li><p>过滤页面内容中的敏感词汇，或者对指定字符组合进行替换 </p></li><li><p>从字符串中提取我们想要的特定部分</p></li></ol></li></ol></li><li><p>特点：</p><ol><li><p>灵活性、逻辑性和功能性 （强大）</p></li><li><p>简单高效</p></li><li><p>可读性稍差，不便于记忆（一般复制相关的正则表达式，修改后即可使用）</p></li></ol></li></ul><h3 id="2-正则表达式使用"><a href="#2-正则表达式使用" class="headerlink" title="2.正则表达式使用"></a>2.正则表达式使用</h3><h4 id="2-1创建方式"><a href="#2-1创建方式" class="headerlink" title="2.1创建方式"></a>2.1创建方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">构造函数方式：<span class="hljs-keyword">var</span> regexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/abc/</span>)<br><br>字面量方式：<span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/123/</span><br></code></pre></td></tr></table></figure><h4 id="2-2测试"><a href="#2-2测试" class="headerlink" title="2.2测试"></a>2.2测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;123&#x27;</span>))<span class="hljs-comment">//返回值是布尔值</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-number">123456</span>)); <span class="hljs-comment">// false 不包含123</span><br></code></pre></td></tr></table></figure><h3 id="3-正则表达式中特殊字符"><a href="#3-正则表达式中特殊字符" class="headerlink" title="3.正则表达式中特殊字符"></a>3.正则表达式中特殊字符</h3><p>特殊字符非常多，可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN</a></p><h4 id="3-1边界符（位置符）"><a href="#3-1边界符（位置符）" class="headerlink" title="3.1边界符（位置符）"></a>3.1边界符（位置符）</h4><p>主要用来匹配字符的开始和结束位置:</p><p>   (1) ^: 用来匹配以…开头</p><p>   (2) $: 用来匹配以…结尾</p><p>注意：</p><p>   (1) 不使用 ^ 和 $ 表示只要字符串中包含匹配的内容就返回 true, 可以多出其他任意字符</p><p>   (2) ^ 和 $ 在一起配合使用，表示是精确匹配, 不能多出其他字符也不能少 (必须满足数量和类型都一致)</p><h4 id="3-2字符类"><a href="#3-2字符类" class="headerlink" title="3.2字符类"></a>3.2字符类</h4><p>[xyz]  只要包含x,y,z中任意一个就满足条件</p><p>[^xyz] 字符串中只要有一个不在中括号内的字符就满足规则</p><p>[a-f] :a,b,c,d,e,f</p><p>(xyz): 表示一个整体</p><h4 id="3-3量词符"><a href="#3-3量词符" class="headerlink" title="3.3量词符"></a>3.3量词符</h4><p>*：表示前面的字符出现 0 次或多次, 即可有可无 ( &gt;= 0)</p><p>+：表示前面的字符至少出现 1 次或多次, 即至少出现一次 ( &gt;= 0)</p><p>？：表示前面的字符出现 0 次或 1 次, 要么不出现, 要么只出现 1 次 ( 0 || 1)</p><p>{3}  {3,}  {3,6}：分别表示重复3次；3次及以上；3次到6次</p><h4 id="3-4预定义类"><a href="#3-4预定义类" class="headerlink" title="3.4预定义类"></a>3.4预定义类</h4><p>\d：匹配 0~9 之间的任意一个数字，等价于 [0-9]</p><p>\D: 匹配所有 0~9 之外的字符，非数字，等价于 [ ^0-9]</p><p>\w: 匹配任意的字母、数字和下划线，等价于 [a-zA-Z0-9_]</p><p>\W: 匹配任意的字母、数字和下划线之外的字符，等价于 [ ^0-9a-zA-Z_]</p><p>\s: 匹配所有的空格（包括换行符，制表符，空格符等），等价于 [\t\r\n\v\f]</p><p>\S：匹配所有的非空格符，等价于 [ ^\t\r\n\v\f]</p><p>记忆：所有大写字符表示 “非”, 上述预定义类只表示单个字符</p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h3><p>4.1 <a href="https://c.runoob.com/front-end/854">菜鸟工具</a></p><p>4.2 正则表达式查找和替换（replace，match）</p><p>replace(reg, 替换后的字符) 可以替换字符串中的字符，参数可以是普通字符串，也可以是正则表达式</p><p>指定匹配的模式：</p><p>   （1）/正则表达式/g    全局匹配</p><p>   （2）/正则表达式/i     忽略大小写进行匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abC123abC678abc345c&#x27;</span><br><span class="hljs-comment">// 把所有的 c 替换成 a</span><br>str = str.replace(<span class="hljs-regexp">/c/gi</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">//正则加了g可以全局替换 否则只能替换第一个</span><br><br><span class="hljs-comment">// match 方法可以配合正则表达式, 从字符串中找出所有匹配正则的字符</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d&#123;3&#125;/g</span><br><span class="hljs-keyword">var</span> res = str.match(reg)<br><span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">//返回数组</span><br><br><span class="hljs-comment">// 替换敏感词 (傻叉)</span><br><span class="hljs-keyword">var</span> ipt = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>)<br>ipt.addEventListener(<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.value.replace(<span class="hljs-regexp">/傻\s*叉|s\s*x/gi</span>, <span class="hljs-string">&#x27;**&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-案例"><a href="#5-案例" class="headerlink" title="5.案例"></a>5.案例</h3><p>表单验证</p>]]></content>
    
    
    <categories>
      
      <category>JS笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
